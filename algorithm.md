# 배열 및 Algorithm
* 정확성이 가장 중요하다


# 알고리즘 성능평가(Big-O)
* 더 효율적인 알고리즘인지 판단하는 척도
* 시간복잡도
  * 얼마나 빨리 해결
* 공간복잡도
  * 얼마나 메모리를 적게 사용하는가
* 최선 표기법, 최악 표기법 , 평균 표기법


# 정렬
## 1. 버블 정렬(bubble)
* 앞에서부터 하나씩 하나씩 비교해서 제일 큰수를 맨위로 보내는 과정을 반복한다.


```
1. [3,2,1,0]
2. [2,3,1,0]
 앞에 3,2를 2,3으로 바꾼다.(3이 더 크기 때문에)
3. [2,1,3,0]
 다음 인덱스 두개 1,3을 비교해서 3이 크므로 뒤로 보낸다.
4. [2 1 0 3]
 3이 크므로 0과 3의 위치를 바꾼다.

5 [1 2 0 3]
 다시 앞에서부터 시작한다.
 ...

 이러한 과정을 반복하게 되면 정렬된다.

```


# 카운팅 정렬(counting) / 다이렉트 어드레스 테이블

```
#  b의 인자를 a가 포함되있는지
#    아닌지로 판별하는 방법

# 1)  for문
a = [4,7,9,1,3,5]
b = [2,3,14,1,2,4,3,5,9,7]
c = []
for i in b:
    for j in a:
        if(i==j):
            c.append(True)
            break
        else:
            pass
    else:
        c.append(False)
print(c)
#연산속도는 O(N*M)

```

```
# 1) DAT
a = [4,7,9,1,3,5]
b = [2,3,14,1,2,4,3,5,9,7]
#b의 range만큼의 테이블을 만든다.


c = [0]*15
for i in a:
  c[i] = True
# 이후 생략

#연산속도는 O(N+M)


```





# 삽입 정렬(insert)

# 선택 정렬(selection)

# 퀵 정렬(Quik)

# 합병 정렬(merge)



---

# 알고리즘 실습
## 실력이 늘려면 어떻게 하나요?
* 문제 많이 풀기
* 디버깅

## 디버깅 어떻게?
* IDE 한줄씩 해보자

# Greedy 알고리즘
* 현재 주어진상황에서 최선을 선택, 뒷 일은 생각하지 않음

